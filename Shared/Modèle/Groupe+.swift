//Arachante
// michel  le 18/11/2021
// pour le projet  ConteneurCloudKit
// Swift  5.0  sur macOS  12.0
//
//  2021
//

import Foundation
import CoreData
import MapKit



//MARK: - Requetes -
extension Groupe {
    
    //MARK: Criteres d'extraction depuis le stockage permanent -

    static var extractionGroupes: NSFetchRequest<Groupe> {
      let request: NSFetchRequest<Groupe> = Groupe.fetchRequest()
      request.sortDescriptors = [NSSortDescriptor(keyPath: \Groupe.nom, ascending: true)]
      return request
      }
    
    static var extractionCollaboratifs: NSFetchRequest<Groupe> {
        let requette: NSFetchRequest<Groupe> = Groupe.fetchRequest()
            requette.sortDescriptors = [NSSortDescriptor(keyPath: \Groupe.nom, ascending: true)]
            requette.predicate = NSPredicate(format: "collaboratif == true")
        return requette
        }
}


//MARK: - Manipulation -
extension Groupe {

    
    /// Fournir un groupe pr√©rempli sans sauver le contexte
    /// - Parameters:
    ///   - contexte:
    ///   - nom: du groupe
    /// - Returns: un Groupe
    static func fournirNouveau(contexte:NSManagedObjectContext , nom:String="N/A") -> Groupe {
        
        let    nouveauGroupe = Groupe(context: contexte)
               nouveauGroupe.id = UUID()
               nouveauGroupe.nom = nom
               nouveauGroupe.createur = UserDefaults.standard.string(forKey: "UID") ?? "anonyme"
               nouveauGroupe.collaboratif = false
               nouveauGroupe.valide = true
        return nouveauGroupe
       }

    /// Cr√©ation d'un nouveau couple Groupe/Item
    /// - Parameters:
    ///   - titre: du groupe et du premier Item
    ///   - collaboratif: ou individuel par d√©faut
    static func creer(contexte:NSManagedObjectContext , titre:String="‚ö°Ô∏é‚ö°Ô∏é‚ö°Ô∏é", collaboratif:Bool=false) {
        // cr√©er un Groupe
        let nouveauGroupe = fournirNouveau(contexte: contexte, nom:titre)
            nouveauGroupe.collaboratif = collaboratif
//            nouveauGroupe.createur = UserDefaults.standard.string(forKey: "UID") ?? "anonyme"
//            nouveauGroupe.valide = true
        
        // cr√©er l'Item principal
        let nouvelItem    = Item.fournirNouveau(
            contexte: contexte ,
            titre: "\(titre)_\(nouveauGroupe.items?.count ?? 0)"   )
            
        nouvelItem.principal = nouveauGroupe
        nouveauGroupe.principal = nouvelItem

        // sauver le contexte
        // persistance
        do {
            contexte.name = "Groupe"
            try contexte.save()
            contexte.name = nil

//            try persistance.sauverContexte()
//            contexte.transactionAuthor = nil
            }
        catch {
            //TODO: Peut mieux faire
            let nsError = error as NSError
            fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
            }
        }


    /// Cr√©er un nouvel Item et le faire participer  √† ce groupe collaboratif
    /// - Parameters:
    ///   - contexte: <#contexte description#>
    ///   - titre: de l'item
    func enr√¥ler(contexte:NSManagedObjectContext , titre:String) {
        guard self.collaboratif else {
//            appError = ErrorType(error: .trucQuiVaPas(num: 666))
            print("ERREUR le groupe", self.nom ?? "?" , "n'est pas collaboratif")
            return
            }
        let nouvelItem = Item.fournirNouveau(
            contexte: contexte ,
            titre: "\(self.nom!) \(items?.count ?? 0) \(titre)"   )
        
        nouvelItem.addToGroupes(self)
        self.addToItems(nouvelItem)

        // sauver le contexte
        do {
            contexte.name = "Groupe"
            try contexte.save()
//            contexte.transactionAuthor = nil
            }
        catch {
            //TODO: Peut mieux faire
            let nsError = error as NSError
            fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
            }
        }


    /// Ce groupe incluera un  ou plusieurs items  existants
    /// - Parameters:
    ///   - contexte:
    func enr√¥ler(contexte:NSManagedObjectContext , recrues: Set<Item>) {
        guard self.collaboratif else {
            print("Le groupe", self.nom ?? "" , "n'est pas collaboratif")
            return
            }

        self.items = (self.items as! Set<Item>).union(recrues) as NSSet
        recrues.forEach {nouvelleRecrue in
            print ("‚öæÔ∏é Traitement item", nouvelleRecrue.titre ?? "...")
            var lesGroupesDeLaNouvelleRecrue = nouvelleRecrue.groupes as! Set<Groupe>
            let (ins√©r√©,  apr√®sInsertion) = lesGroupesDeLaNouvelleRecrue.insert(self)
            print("‚öæÔ∏é Ins√©r√© :" , ins√©r√©,
                  "apr√®s :"  , apr√®sInsertion,
                  "les"      , lesGroupesDeLaNouvelleRecrue.count,
                  "groupes :", lesGroupesDeLaNouvelleRecrue)
            }
        }
   }



//MARK: - Propriet√©s -

extension Groupe {
    
    var vide:Groupe {
        Groupe()
        }
    
    // principal: Item?
    var lePrincipal:Item  {
//        get throws {
        get  {
            if principal != nil { return principal! }
            else {
                // plutot generer une erreur ?
    //            appError = ErrorType(error: .groupeSansPrincipal)
//                throw Nimbus.groupeSansPrincipal
                // donc la suite n'est pas execut√©e
                fatalError("üî¥ ERREUR le principal de \( nom ?? "") n'existe pas !!")
                print("üî¥ ERREUR le principal de", nom ?? "" , "n'existe pas !!")
                return Item.bidon() }
        }
        }
    
    /// Convertir .items:NSSet? en .lesItems:Set<Item>
    var lesItems:Set<Item> { return items as? Set<Item> ?? [] }
    
    var talbeauItemTri√©: [Item] {
        let set = items as? Set<Item> ?? []
        return set.sorted {
            $0.titre ?? "" < $1.titre ?? ""
            }
        }
    
    
    var leNom:String {
        get {nom ?? "‚êÄ"}
        set {nom = newValue}
        }
    
    /// La valeur d'un groupe, c'est la somme (Int) des valeurs (Int64) de ses participants
    var valeur:Int { Int(
        (items as? Set<Item>)? .reduce(principal?.valeur ?? 0) {$0 + $1.valeur} ?? 0)
        }
    
    var valeurPrincipale: Int {
        get { Int(principal?.valeur ?? 0) }
        set {
            print("‚òëÔ∏èAVANT", principal?.valeur)
            print("‚òëÔ∏èNOUVELLE", newValue)
            principal?.valeur = Int64(newValue)
//            integration = Int64(newValue)
            print("‚òëÔ∏èAPRES", principal?.valeur)
        }
    }
    
    
    var lesCoordonn√©es:[CLLocationCoordinate2D] {
        lesItems.map {$0.coordonn√©es}
        }
                
    var r√©gionEnglobante: MKCoordinateRegion  {
        print("\n\nüèÅüèÅ ")
            var toutesLesCoordonn√©es:[CLLocationCoordinate2D]
            
            if let lePrincipal = principal?.coordonn√©es {
                toutesLesCoordonn√©es = [lePrincipal]
                toutesLesCoordonn√©es.append(contentsOf: lesCoordonn√©es)
                }
            else {
                toutesLesCoordonn√©es = lesCoordonn√©es
                }

        toutesLesCoordonn√©es.forEach() {coord in print("üèÅ ¬∫", coord.longitude, coord.latitude)}
        print("üèÅ")
        
        // Aucun point : on affiche le monde
        if toutesLesCoordonn√©es.isEmpty {
            return  MKCoordinateRegion(
                    center: CLLocationCoordinate2D(
                        latitude:  0,
                        longitude: 0),
                    span: Lieu.r√©gionMax
//                        MKCoordinateSpan(
//                        latitudeDelta:  180,
//                        longitudeDelta: 360
//                        )
                    )
            }
        
        // Un seul point (normalement le Principal)
        if toutesLesCoordonn√©es.count == 1 {
            return  MKCoordinateRegion(
            center: CLLocationCoordinate2D(
                latitude:  toutesLesCoordonn√©es.first?.latitude  ?? 0,
                longitude: toutesLesCoordonn√©es.first?.longitude ?? 0),
            span: Lieu.r√©gionParD√©faut
//                        MKCoordinateSpan(
//                        latitudeDelta:  180,
//                        longitudeDelta: 360
//                        )
            )
    }
        
        let lesLongitudes = toutesLesCoordonn√©es.map {$0.longitude}
        let lesLatitudes  = toutesLesCoordonn√©es.map {$0.latitude}
        
      
        
        let P1 = CLLocationCoordinate2D(latitude: lesLatitudes.min()!, longitude: lesLongitudes.min()!)
        let P2 = CLLocationCoordinate2D(latitude: lesLatitudes.max()!, longitude: lesLongitudes.max()!)
        print("üèÅ Min Min", P1.longitude, P1.latitude)
        print("üèÅ Max Max", P2.longitude, P2.latitude)

        let   œÄ = Double.pi
        let _2œÄ = 2 * œÄ
        let _3œÄ = 3 * œÄ

        let Rad = œÄ/180
        let Deg = 180/œÄ
        
        let œÜ1 = P1.latitude * Rad
        let œÜ2 = P2.latitude * Rad
        
        let Œª1 = P1.longitude * Rad
        let Œª2 = P2.longitude * Rad
        
        let ŒîŒª = Œª2 - Œª1 // long
        let ŒîœÜ = œÜ2 - œÜ1  // lat
        
        print("üèÅ Delta long", ŒîŒª ,  "lat", ŒîœÜ)


// https://www.movable-type.co.uk/scripts/latlong.html
//        Bx = cos œÜ2 ‚ãÖ cos ŒîŒª
//        By = cos œÜ2 ‚ãÖ sin ŒîŒª
//        œÜm = atan2( sin œÜ1 + sin œÜ2, ‚àö(cos œÜ1 + Bx)¬≤ + By¬≤ )
//        Œªm = Œª1 + atan2(By, cos(œÜ1)+Bx)
//--------------------------------------------------------------
// Voir aussi https://stackoverflow.com/questions/4169459/whats-the-best-way-to-zoom-out-and-fit-all-annotations-in-mapkit
        
// atan2 returne des valeurs entre -œÄ ... +œÄ ( -180¬∞ ... +180¬∞)
// afin de normaliser en une valeur entre 0¬∞ et 360¬∞, with ‚àíve values ttransform√©es entre 180¬∞ ... 360¬∞),
// convertir en degrees and then use (Œ∏+360) % 360 ( % <=> truncatingRemainder(dividingBy) )
        
//        For final bearing, simply take the initial bearing from the end point to the start point and reverse it (using Œ∏ = (Œ∏+180) % 360).
        
        let Bx = cos(œÜ2) * cos(ŒîŒª)
        let By = cos(œÜ2) * sin(ŒîŒª)
        let œÜm = atan2(sin(œÜ1) + sin(œÜ2), sqrt( (cos(œÜ1)+Bx)*(cos(œÜ1)+Bx) + By*By ) )
        let Œªm = Œª1 + atan2(By, cos(œÜ1) + Bx)
        // Normaliser la longitude entre -180¬∞ et +180¬∞
        let Œªm_ = (Œªm + _3œÄ).truncatingRemainder(dividingBy: _2œÄ) -  œÄ
        // l'ecart de longitude
        let ŒîŒª_ = abs((ŒîŒª + _3œÄ).truncatingRemainder(dividingBy: _2œÄ) -  œÄ)
        
        // ??? Normaliser la latitude entre -90¬∞ et +90¬∞ ?
//        let œÜm_ = œÜm * -1 //(œÜm + (3 * œÄ / 2).truncatingRemainder(dividingBy: œÄ) -  (œÄ / 2))
//        let œÜm_ = (œÜm + œÄ) .truncatingRemainder(dividingBy:_2œÄ) - œÄ // INCHANG√â ...
//        let œÜm_ = (œÜm + (3 * œÄ / 2)).truncatingRemainder(dividingBy: œÄ) -  (œÄ / 2) // INCHANG√â
        let œÜm_ = (œÜm +   (œÄ / 2 ) ).truncatingRemainder(dividingBy: œÄ) -  (œÄ / 2)
//        let œÜm_ = (œÜm +   (œÄ / 2 ) ).truncatingRemainder(dividingBy: œÄ) -  (œÄ / 2)

        print("üèÅ œÜm brut", œÜm * Deg, "normalis√©", œÜm_ * Deg)

        // ???? l'ecart de latitude
        let ŒîœÜ_ = (ŒîœÜ + (3 * œÄ / 2).truncatingRemainder(dividingBy: œÄ) -  (œÄ / 2))


        let P_milieu = CLLocationCoordinate2D(latitude:œÜm_ * Deg, longitude: Œªm_ * Deg)
        print ("üèÅ Le centre de ", P1.longitude, P1.latitude , "  et  ", P2.longitude, P2.latitude)
        print ("üèÅ est", P_milieu.longitude, P_milieu.latitude)
        print ("üèÅ l'√©cart en longitude est de", ŒîŒª * Deg, ŒîŒª_ * Deg ,"¬∞" )
        print ("üèÅ l'√©cart en  latitude est de", ŒîœÜ * Deg, ŒîœÜ_ * Deg ,"¬∞" )

        // normaliser la longitude entre  ‚àí180‚Ä¶+180 : (lon+540)%360-180
        // truncatingRemainder
        // (Œª3+540).truncatingRemainder(dividingBy: 360) - 180
        
        // √âlargir l'envergure de la zone de 5% 0.5
        // let envergure = MKCoordinateSpan(
        // latitudeDelta:  (ecartLatitudes  + (ecartLatitudes  * 0.5)).truncatingRemainder(dividingBy: 180),
        // longitudeDelta: (ecartLongitudes + (ecartLongitudes * 0.5)).truncatingRemainder(dividingBy: 360))
            let envergure = MKCoordinateSpan(
                // En degr√©e et un peu d'espace autour
                latitudeDelta:  ŒîœÜ_ * Deg * 1.5,
                longitudeDelta: ŒîŒª_ * Deg * 1.5
                )
        
            // MapKit ne peut pas afficher l'ensemble du globe,
            // pour la r√©gion ci dessous il faut faire defiler la carte.
            // Detecter et pr√©venir que l'on depasse le facteur de zoom MapKit.  C'est lequel ??
            // max latitudeDelta : 180
            // cf regionThatFits
           _ = Lieu.r√©gionMax
        
//        MKCoordinateSpan(
//                latitudeDelta:  180,
//                longitudeDelta: 360
//                )

            print ("üèÅ Carte Milieu", P_milieu.longitude, P_milieu.latitude )
            print ("üèÅ Carte Envergure long", envergure.longitudeDelta , "lat", envergure.latitudeDelta)

            let r√©gion = MKCoordinateRegion(center: P_milieu, span: envergure) //envergureMondiale)
//            let r√©gionAdapt√©e = regionThatFits(r√©gion)
//        MapKit.MKCoordinateRegion.   regionThatFits(r√©gion)
            return r√©gion
        }
    
    // regroupe les descriptions des lieux des membres du groupe (sans celle du principal)
    var lesAnnotations_:[AnnotationGeographique] {
        lesItems.map {$0.annotationGeographiques}
        }
    
    // Regroupe les descriptions des lieux des membres du groupe
    // ET celle de l'item principal du groupe
    var lesAnnotations:[AnnotationGeographique] {
        var toutesLesAnnotations:[AnnotationGeographique]
        
        if let lePrincipal:AnnotationGeographique = principal?.annotationGeographiques {
            toutesLesAnnotations = [lePrincipal]
            toutesLesAnnotations.append(contentsOf: lesAnnotations_)
            }
        else {
            
            toutesLesAnnotations = lesAnnotations_
            }
        print ("Nous avons", toutesLesAnnotations.count, "annotations")
        return toutesLesAnnotations
        }

    func estContenu(dans groupes : Set<Groupe>) -> Bool { groupes.contains(self)}
    
//    override public func prepareForDeletion() {
//        super.prepareForDeletion()
//        print("üîò Suppresion imminente du groupe ", nom ?? "...",
//              ", maitre de l'item principal", principal?.titre,
//              "et de", items?.count, "autres items.")
//        }

    }


