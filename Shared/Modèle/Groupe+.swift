//Arachante
// michel  le 18/11/2021
// pour le projet  ConteneurCloudKit
// Swift  5.0  sur macOS  12.0
//
//  2021
//

import Foundation
import CoreData
import MapKit



//MARK: - Requ√™tes -
extension Groupe {
    
    //MARK: Crit√®res d'extraction depuis le stockage permanent -

    static var extractionGroupes: NSFetchRequest<Groupe> {
      let request: NSFetchRequest<Groupe> = Groupe.fetchRequest()
      request.sortDescriptors = [NSSortDescriptor(keyPath: \Groupe.nom, ascending: true)]
      return request
      }
    
    static var extractionCollaboratifs: NSFetchRequest<Groupe> {
        let requette: NSFetchRequest<Groupe> = Groupe.fetchRequest()
            requette.sortDescriptors = [NSSortDescriptor(keyPath: \Groupe.nom, ascending: true)]
            requette.predicate = NSPredicate(format: "collaboratif == true")
        return requette
        }
}


//MARK: - Manipulation -
extension Groupe {

    
    /// Fournir un groupe pr√©rempli sans sauver le contexte
    /// - Parameters:
    ///   - contexte:
    ///   - nom: du groupe
    /// - Returns: un Groupe
    static func fournirNouveau(contexte:NSManagedObjectContext , nom:String="‚êÄ") -> Groupe {
        
        let    nouveauGroupe = Groupe(context: contexte)
               nouveauGroupe.id = UUID()
               nouveauGroupe.nom = nom
               nouveauGroupe.createur = UserDefaults.standard.string(forKey: "UID") ?? "anonyme"
               nouveauGroupe.collaboratif = false
               nouveauGroupe.valide = true
        return nouveauGroupe
       }

    /// Cr√©ation d'un nouveau couple Groupe/Item
    /// - Parameters:
    ///   - titre: du groupe et du premier Item
    ///   - collaboratif: ou individuel par d√©faut
    static func creer(contexte:NSManagedObjectContext , titre:String="‚ö°Ô∏é‚ö°Ô∏é‚ö°Ô∏é", collaboratif:Bool=false) {
        // Cr√©er un Groupe
        let nouveauGroupe = fournirNouveau(contexte: contexte, nom:titre)
            nouveauGroupe.collaboratif = collaboratif
//            nouveauGroupe.createur = UserDefaults.standard.string(forKey: "UID") ?? "anonyme"
//            nouveauGroupe.valide = true
        
        // Cr√©er l'Item principal
        let nouvelItem    = Item.fournirNouveau(
            contexte: contexte ,
            titre: "\(titre)_\(nouveauGroupe.items?.count ?? 0)"   )
            
        nouvelItem.principal    = nouveauGroupe
        nouveauGroupe.principal = nouvelItem

        // sauver le contexte
        // persistance
        do {
            contexte.name = "Groupe"
            try contexte.save()
            contexte.name = nil

//            try persistance.sauverContexte()
//            contexte.transactionAuthor = nil
            }
        catch {
            //TODO: Peut mieux faire
            let nsError = error as NSError
            fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
            }
        }


    /// Cr√©er un nouvel Item et le faire participer  √† ce groupe collaboratif
    /// - Parameters:
    ///   - contexte: <#contexte description#>
    ///   - titre: de l'item
    func enr√¥ler(contexte:NSManagedObjectContext , titre:String) {
        guard self.collaboratif else {
//            appError = ErrorType(error: .trucQuiVaPas(num: 666))
            print("ERREUR le groupe", self.nom ?? "?" , "n'est pas collaboratif")
            return
            }
        let nouvelItem = Item.fournirNouveau(
            contexte: contexte ,
            titre: "\(self.nom!) \(items?.count ?? 0) \(titre)"   )
        
        nouvelItem.addToGroupes(self)
        self.addToItems(nouvelItem)

        // sauver le contexte
        do {
            contexte.name = "Groupe"
            try contexte.save()
            contexte.name = nil
            }
        catch {
            //TODO: Peut mieux faire
            let nsError = error as NSError
            fatalError("Unresolved error \(nsError), \(nsError.userInfo)")
            }
        }


    /// Ce groupe incluera un  ou plusieurs items  existants
    /// - Parameters:
    ///   - contexte:
    func enr√¥ler(contexte:NSManagedObjectContext , recrues: Set<Item>) {
        guard self.collaboratif else {
            print("Le groupe", self.nom ?? "" , "n'est pas collaboratif")
            return
            }

        self.items = (self.items as! Set<Item>).union(recrues) as NSSet
        recrues.forEach {nouvelleRecrue in
            print ("‚öæÔ∏é Traitement item", nouvelleRecrue.titre ?? "...")
            var lesGroupesDeLaNouvelleRecrue = nouvelleRecrue.groupes as! Set<Groupe>
            let (ins√©r√©,  apr√®sInsertion) = lesGroupesDeLaNouvelleRecrue.insert(self)
            print("‚öæÔ∏é Ins√©r√© :" , ins√©r√©,
                  "apr√®s :"  , apr√®sInsertion,
                  "les"      , lesGroupesDeLaNouvelleRecrue.count,
                  "groupes :", lesGroupesDeLaNouvelleRecrue)
            }
        }
   }



//MARK: - Propri√©t√©s -

extension Groupe {
    
    var vide:Groupe {
        Groupe()
        }
    
    // principal: Item?
    var lePrincipal:Item  {
        get  {
            if principal != nil { return principal! }
            else {
                // plutot generer une erreur ?
                // appError = ErrorType(error: .groupeSansPrincipal)
                // throw Nimbus.groupeSansPrincipal
                // donc la suite n'est pas execut√©e
                fatalError("üî¥ ERREUR le principal de \( nom ?? "") n'existe pas !!")
//              print("üî¥ ERREUR le principal de", nom ?? "" , "n'existe pas !!")
//              return Item.bidon() }
                }
            }
        }
    
    /// Convertir .items:NSSet? en .lesItems:Set<Item> et reciproquement
    var lesItems:Set<Item> {
        get {return items as? Set<Item> ?? []}
        set {items =  newValue as NSSet } // adding(newValue)
    }
    
    /// Pas utilis√©
    var tableauItemsTri√©: [Item] {
        let set = items as? Set<Item> ?? []
        return set.sorted {
            $0.leTitre < $1.leTitre
            }
        }
    
    /// Le nom  non optionel du groupe
    var leNom:String {
        get {nom ?? "‚êÄ"}
        set {nom = newValue}
        }
    
    /// La valeur d'un groupe, c'est la somme (Int) des valeurs (Int64) de ses participants
    var valeur:Int { Int(
        (items as? Set<Item>)? .reduce(principal?.valeur ?? 0) {$0 + $1.valeur} ?? 0)
        }
    
    /// La valeur de l'Item Principal de ce groupe
    var valeurPrincipale: Int {
        get { Int(principal?.valeur ?? 0) }
        set { principal?.valeur = Int64(newValue) }
        }
    
    /// Vrai si l'ensemble des groupes sont collaboratifs
    static func tousCollaboratifs(_ lesGroupes: Set<Groupe> ) -> Bool {
        lesGroupes.reduce(true) {$0 && $1.collaboratif}
        }
    
    /// Liste des groupes en adh√©rence
    func collaborateurs_() -> Set<Groupe> {
        guard items?.count ?? 0 > 0 else { return Set<Groupe>() }
        return Set( ((items as? Set<Item>)?.map {$0.principal!})! )
        }
    
    /// L'ensemble des groupes  principaux des Items li√©s √† ce Groupe
    var collaborateurs : Set<Groupe> {
        guard items?.count ?? 0 > 0 else { return Set<Groupe>() }
        return Set( ((items as? Set<Item>)?.map {$0.principal!})! )
        }
    
    var collaborateursSansLePrincipal : Set<Groupe> {
        guard items?.count ?? 0 > 0 else { return Set<Groupe>() }

        lesItems.remove(lePrincipal)
        return Set( ((items as? Set<Item>)?.map {$0.principal!})! )
        }

    func estMonPrincipal(groupe:Groupe) -> Bool {
        groupe.lePrincipal == self.lePrincipal
        }
    
    //MARK: Manipulation du double lien entre Groupes collaborateurs
    // 1Ô∏è‚É£ De ma liste d'items vers l'item principal de l'autre        et
    // 2Ô∏è‚É£ De la liste de groupes de l'item principal de l'autre vers moi
    
    /// Recruter un autre `Groupe`,  c'est √† dire recruter l'`Item Principal` de ce `Groupe`
    func enroler(recrue:Groupe) {
        guard recrue.principal != nil else {return}
        print(">>> LES ITEMS AVANT", lesItems)
        print(">>> LES GROUPES AVANT", recrue.principal!.lesGroupes)

        // Ajouter √† ma liste d'Items, l'Item Principal de la recrue
        self.lesItems.insert(recrue.principal!)
        // M'ajouter aux groupes de l'Item Principal de la recrue
        recrue.principal?.lesGroupes.insert(self)
        
        print(">>> LES ITEMS APRES", lesItems)
        print(">>> LES APRES", recrue.principal!.lesGroupes)
        }
    
    func enroler_(recrue:Groupe) {
        guard recrue.principal != nil else {return}
        print(">>> PRINCIPAL", recrue.principal!.leTitre)
        print(">>> LES ITEMS", lesItems)
        print(">>> LES GROUPES", recrue.principal!.lesGroupes)
        }
    
    /// R√©voquer un `Groupe` recrut√©, c'est √† dire r√©voquer l'`Item Principal` de ce `Groupe`
    func r√©voquer(recrue:Groupe) {
        // Enlever l'Item Principal de la recrue, de ma liste d'Items.
        self.lesItems.remove(recrue.principal!)
        // M'enlever des groupes de l'Item Principal de la recrue
        recrue.principal?.lesGroupes.remove(self)
        }
    
    /// Rejoindre et collaborer √† un  `Groupe` leader, c'est √† dire que mon  `Item Principal` participera  au Groupe leader
    func rallier(groupeLeader:Groupe) {
        guard principal != nil else {return}
        // Ajouter mon item principal √† l'ensemble d'item du groupe leader
        groupeLeader.lesItems.insert(self.principal!) // ou lePrincipal)
        // Ajouter le groupe leader √† l'ensemble de groupes auquels mon item principal participe
        self.principal!.lesGroupes.insert(groupeLeader)
        }
        
        
// Equivalent √† :
//        self.principal?.rallier(groupeLeader: groupeLeader)
        
//        if Groupe.tousCollaboratifs(self.lesGroupes) {print("OK")}
//        groupeLeader.lesItems.insert(self)
//        // et la r√©ciproque ajouter le patron √† ma liste de Groupe
//        self.lesGroupes.insert(groupeLeader)
       
 
          
    func demissioner(groupeLeader:Groupe) {
        guard principal != nil else {return}
        // Elever mon item principal de l'ensemble d'item du groupe leader
        groupeLeader.lesItems.remove(self.principal!)
//        groupeLeader.removeFromItems(self.principal!)

        // Enlever le groupe leader de l'ensemble de groupes auquels mon item principal participe
        self.principal!.lesGroupes.remove(groupeLeader)
//        groupeLeader.removeFromItems(self.principal!.items)
        }

    /*
     Groupe
        addToItems(     _ value:  Item )
        removeFromItems(_ value:  Item )
        addToItems(     _ values: NSSet)
        removeFromItems(_ values: NSSet)
     
     Item
        addToGroupes(     _ value: Groupe)
        removeFromGroupes(_ value: Groupe)
        addToGroupes(     _ values: NSSet)
        removeFromGroupes(_ values: NSSet)
     */
    
    
    //MARK: G√©ographie
    
    /// Le tableau des coordonn√©es des Items li√©s √† ce groupe
    var lesCoordonn√©es:[CLLocationCoordinate2D] {
        lesItems.map {$0.coordonn√©es}
        }
    
    var r√©gionEnglobante_: MKCoordinateRegion {
        set {} //self.r√©gionEnglobante_ = newValue}
        get {MKCoordinateRegion()}
    }
    
    /// La r√©gion g√©ographique qui  englobe  l'ensemble des Items du Groupe
    var r√©gionEnglobante: MKCoordinateRegion  {

        get {
            var toutesLesCoordonn√©es = lesCoordonn√©es
            if let lePrincipal = principal?.coordonn√©es {
                toutesLesCoordonn√©es.append(lePrincipal)
                }
                    
            // Aucun point : on affiche le monde
            if toutesLesCoordonn√©es.isEmpty {
                return  MKCoordinateRegion(
                        center: CLLocationCoordinate2D(
                            latitude:  0,
                            longitude: 0),
                        span: Lieu.√©tendueMax
                        )
                }
            
            // Un seul point (normalement le Principal)
            if toutesLesCoordonn√©es.count == 1 {
                return  MKCoordinateRegion(
                    center: CLLocationCoordinate2D(
                        latitude:  toutesLesCoordonn√©es.first?.latitude  ?? 0,
                        longitude: toutesLesCoordonn√©es.first?.longitude ?? 0),
                    span: Lieu.√©tendueParD√©faut
                    )
                }
            
            // Sinon on fait un peu de trigonom√©trie
            return MKCoordinateRegion.englobante(lesCoordonn√©es: toutesLesCoordonn√©es)
            }
        set {r√©gionEnglobante_ = newValue}
        
        }
        //MARK: G√©ographie
        /// En entr√©e toutesLesCoordonn√©es    : [CLLocationCoordinate2D]
        /// En sortie la r√©gion: MKCoordinateRegion  englobant toutesLesCoordonn√©es
        //TODO: Certainement √† d√©placer (vers Lieu)
        
#warning("Attention ...    ")
//#error("Erreur ! ")
//        let r√©gion = MKCoordinateRegion.englobante(lesCoordonn√©es: toutesLesCoordonn√©es)
        
//        let lesLongitudes = toutesLesCoordonn√©es.map {$0.longitude}
//        let lesLatitudes  = toutesLesCoordonn√©es.map {$0.latitude}
//
//
//        let P1 = CLLocationCoordinate2D(latitude: lesLatitudes.min()!, longitude: lesLongitudes.min()!)
//        let P2 = CLLocationCoordinate2D(latitude: lesLatitudes.max()!, longitude: lesLongitudes.max()!)
//        print("üèÅ Min Min", P1.longitude, P1.latitude)
//        print("üèÅ Max Max", P2.longitude, P2.latitude)
//
//        let   œÄ = Double.pi
//        let _2œÄ = 2 * œÄ
//        let _3œÄ = 3 * œÄ
//
//        let Rad = œÄ/180
//        let Deg = 180/œÄ
//
//        let œÜ1 = P1.latitude * Rad
//        let œÜ2 = P2.latitude * Rad
//
//        let Œª1 = P1.longitude * Rad
//        let Œª2 = P2.longitude * Rad
//
//        let ŒîŒª = Œª2 - Œª1 // long
//        let ŒîœÜ = œÜ2 - œÜ1  // lat
//
//        print("üèÅ Delta long", ŒîŒª ,  "lat", ŒîœÜ)
//
//
//// https://www.movable-type.co.uk/scripts/latlong.html
////        Bx = cos œÜ2 ‚ãÖ cos ŒîŒª
////        By = cos œÜ2 ‚ãÖ sin ŒîŒª
////        œÜm = atan2( sin œÜ1 + sin œÜ2, ‚àö(cos œÜ1 + Bx)¬≤ + By¬≤ )
////        Œªm = Œª1 + atan2(By, cos(œÜ1)+Bx)
////--------------------------------------------------------------
//// Voir aussi https://stackoverflow.com/questions/4169459/whats-the-best-way-to-zoom-out-and-fit-all-annotations-in-mapkit
//
//// atan2 returne des valeurs entre -œÄ ... +œÄ ( -180¬∞ ... +180¬∞)
//// afin de normaliser en une valeur entre 0¬∞ et 360¬∞, with ‚àíve values ttransform√©es entre 180¬∞ ... 360¬∞),
//// convertir en degrees and then use (Œ∏+360) % 360 ( % <=> truncatingRemainder(dividingBy) )
//
////        For final bearing, simply take the initial bearing from the end point to the start point and reverse it (using Œ∏ = (Œ∏+180) % 360).
//
//        let Bx = cos(œÜ2) * cos(ŒîŒª)
//        let By = cos(œÜ2) * sin(ŒîŒª)
//        let œÜm = atan2(sin(œÜ1) + sin(œÜ2), sqrt( (cos(œÜ1)+Bx)*(cos(œÜ1)+Bx) + By*By ) )
//        let Œªm = Œª1 + atan2(By, cos(œÜ1) + Bx)
//        // Normaliser la longitude entre -180¬∞ et +180¬∞
//        let Œªm_ = (Œªm + _3œÄ).truncatingRemainder(dividingBy: _2œÄ) -  œÄ
//        // l'ecart de longitude
//        let ŒîŒª_ = abs((ŒîŒª + _3œÄ).truncatingRemainder(dividingBy: _2œÄ) -  œÄ)
//
//        // ??? Normaliser la latitude entre -90¬∞ et +90¬∞ ?
////        let œÜm_ = œÜm * -1 //(œÜm + (3 * œÄ / 2).truncatingRemainder(dividingBy: œÄ) -  (œÄ / 2))
////        let œÜm_ = (œÜm + œÄ) .truncatingRemainder(dividingBy:_2œÄ) - œÄ // INCHANG√â ...
////        let œÜm_ = (œÜm + (3 * œÄ / 2)).truncatingRemainder(dividingBy: œÄ) -  (œÄ / 2) // INCHANG√â
//        let œÜm_ = (œÜm +   (œÄ / 2 ) ).truncatingRemainder(dividingBy: œÄ) -  (œÄ / 2)
////        let œÜm_ = (œÜm +   (œÄ / 2 ) ).truncatingRemainder(dividingBy: œÄ) -  (œÄ / 2)
//
//        print("üèÅ œÜm brut", œÜm * Deg, "normalis√©", œÜm_ * Deg)
//
//        // ???? l'ecart de latitude
//        let ŒîœÜ_ = (ŒîœÜ + (3 * œÄ / 2).truncatingRemainder(dividingBy: œÄ) -  (œÄ / 2))
//
//
//        let P_milieu = CLLocationCoordinate2D(latitude:œÜm_ * Deg, longitude: Œªm_ * Deg)
//        print ("üèÅ Le centre de ", P1.longitude, P1.latitude , "  et  ", P2.longitude, P2.latitude)
//        print ("üèÅ est", P_milieu.longitude, P_milieu.latitude)
//        print ("üèÅ l'√©cart en longitude est de", ŒîŒª * Deg, ŒîŒª_ * Deg ,"¬∞" )
//        print ("üèÅ l'√©cart en  latitude est de", ŒîœÜ * Deg, ŒîœÜ_ * Deg ,"¬∞" )
//
//        // normaliser la longitude entre  ‚àí180‚Ä¶+180 : (lon+540)%360-180
//        // truncatingRemainder
//        // (Œª3+540).truncatingRemainder(dividingBy: 360) - 180
//
//        // √âlargir l'envergure de la zone de 5% 0.5
//        // let envergure = MKCoordinateSpan(
//        // latitudeDelta:  (ecartLatitudes  + (ecartLatitudes  * 0.5)).truncatingRemainder(dividingBy: 180),
//        // longitudeDelta: (ecartLongitudes + (ecartLongitudes * 0.5)).truncatingRemainder(dividingBy: 360))
//            let envergure = MKCoordinateSpan(
//                // En degr√©e et un peu d'espace autour
//                latitudeDelta:  ŒîœÜ_ * Deg * 1.5,
//                longitudeDelta: ŒîŒª_ * Deg * 1.5
//                )
//
//            // MapKit ne peut pas afficher l'ensemble du globe,
//            // pour la r√©gion ci dessous il faut faire defiler la carte.
//            // Detecter et pr√©venir que l'on depasse le facteur de zoom MapKit.  C'est lequel ??
//            // max latitudeDelta : 180
//            // cf regionThatFits
//           _ = Lieu.√©tendueMax
//
////        MKCoordinateSpan(
////                latitudeDelta:  180,
////                longitudeDelta: 360
////                )
//
//            print ("üèÅ Carte Milieu", P_milieu.longitude, P_milieu.latitude )
//            print ("üèÅ Carte Envergure long", envergure.longitudeDelta , "lat", envergure.latitudeDelta)
//
//            let r√©gion = MKCoordinateRegion(center: P_milieu, span: envergure) //envergureMondiale)
////            let r√©gionAdapt√©e = regionThatFits(r√©gion)
////        MapKit.MKCoordinateRegion.   regionThatFits(r√©gion)
//        }
    
    
    /// Regroupe les descriptions des lieux des membres du groupe (sans celle du principal)
    var lesAnnotations_:[AnnotationGeographique] {
        lesItems.map {$0.annotationGeographiques}
        }
    
    /// Regroupe les descriptions des lieux des membres du groupe
    /// ET celle de l'item principal du groupe
    var lesAnnotations:[AnnotationGeographique] {
        var toutesLesAnnotations:[AnnotationGeographique]
        
        if let lePrincipal:AnnotationGeographique = principal?.annotationGeographiques {
            toutesLesAnnotations = [lePrincipal]
            toutesLesAnnotations.append(contentsOf: lesAnnotations_)
            }
        else {
            
            toutesLesAnnotations = lesAnnotations_
            }
        print ("Nous avons", toutesLesAnnotations.count, "annotations")
        return toutesLesAnnotations
        }

    /// Vrai si ce Groupe est contenu dans l'ensemble des Groupes en argument
    func estContenu(dans groupes : Set<Groupe>) -> Bool { groupes.contains(self)}
    
    
//    override public func prepareForDeletion() {
//        super.prepareForDeletion()
//        print("üîò Suppresion imminente du groupe ", nom ?? "...",
//              ", maitre de l'item principal", principal?.titre,
//              "et de", items?.count, "autres items.")
//        }

    
}
    
    


//MARK: - Pour Tests -
    
extension Groupe {

    
    func verifierCoh√©rence(depuis:String="‚êÄ" ) -> [ErrorType]   {
        var lesErreurs = [ErrorType]()
        print("‚òëÔ∏è Coh√©rence du groupe", nom ?? "‚êÄ" , ", depuis" , depuis, terminator: " :")
        
        if !valide
            {lesErreurs.append(ErrorType(.groupeInvalide ))}
        
        if (nom == nil || nom!.isEmpty || nom == "")
            {lesErreurs.append(ErrorType(.groupeSansNom ))}
        
        if (id == nil )
            { lesErreurs.append(ErrorType(.groupeSansID )) }
        
        if principal == nil
            { lesErreurs.append(ErrorType(.itemSansPrincipal ))}
        
        
        
        if lesErreurs.isEmpty {print(" ‚úÖ")}
        else {
            print("")
            lesErreurs.forEach() {print("‚òëÔ∏è‚ùå" , $0.error.localizedDescription)}}
        
        return lesErreurs
        }
    }






